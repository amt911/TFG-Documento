\chapter{Implementación}

Este capítulo tratará sobre las herramientas utilizadas para la implementación y planificación, así como los distintos algoritmos que se emplearán para realizar la simulación. Además, se detallará el diseño de los \textit{blueprints} y se describirán las reglas que seguirá el algoritmo de navegación.

\section{Herramientas utilizadas}

En el desarrollo del proyecto se utilizará \verb|git| para el control de versiones del proyecto.
%  y se almacenará en un repositorio de GitHub. 

\bigskip

Para el modelado, texturizado de los distintos objetos de la aplicación y el \textit{rigging} de los vehículos se utilizará Blender\cite{blender}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imagenes/blender-logo.png}
    \caption{Logotipo de Blender\cite{blender-logo}.}
    \label{fig:logoblender}
\end{figure}

Asimismo, para la creación y modificación de las texturas se utilizará GIMP\cite{gimp}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{imagenes/gimp-logo.png}
    \caption{Logotipo de GIMP\cite{gimp}.}
    \label{fig:logogimp}
\end{figure}

\bigskip

% En cuanto a herramientas para la planificación, se hará uso de la herramienta \planApp para llevar un control de las Historias de Usuario que se realizan y pendientes en cada Sprint.
En lo que respecta a herramientas de planificación, se utilizará \planApp para llevar un control de las historias de usuario realizadas y pendientes en cada sprint. Además, se utilizará el \textit{power-up} ``Card Priority Badge'' de ``Kryl Solutions'' para poder anotar la prioridad de cada historia de usuario. Asimismo, se hará uso del \textit{power-up} ``Agile Tools by Corrello'' para poder tener estimaciones en las historias de usuario.

% foto de \planApp
% \begin{figure}[H]
%     \centering
%     \includegraphics[width=\textwidth]{imagenes/converted/trello.jpg}
%     \caption{Tablero de ejemplo de Trello\cite{tablero-trello}.}
% \end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/trello-mio-reduced.png}
    \caption{Tablero utilizado para el proyecto.}
\end{figure}

\newpage

\section{Glosario de términos de Unreal}
\label{sec:terminosunreal}
Esta sección es utilizada como una breve explicación de las palabras utilizadas referentes a Unreal Engine en este capítulo:

\begin{itemize}
    \item \textbf{Blueprint: }Forma visual de implementar lógica en el videojuego mediante el uso de nodos y aristas. Permiten programar sin necesidad de conocer la API en C++.
    \item \textbf{Evento (Event): }Acción o suceso que ocurre durante el juego y que puede desencadenar acciones o comportamiento. Los eventos pueden estar relacionados con el jugador, colisión entre objetos, etc.
    \item \textbf{Actor: }Es un objeto del mundo que puede tener presencia física, implementar comportamiento específico y ser creados en tiempo de ejecución. A grandes rasgos son una clase que pueden tener mallas de polígonos almacenadas.
    \item \textbf{Peón: }Tipo de actor que puede ser controlado directamente por el jugador. Por lo general, los peones representan personajes jugables en el juego.
    \item \textbf{Event ActorBeginOverlap: }Evento utilizado cuando un actor se superpone con otro actor. Puede ser utilizado para realizar acciones en caso de colisión.
    \item \textbf{Event ActorEndOverlap: }Evento que se activa cuando un actor deja de solaparse con otro. Puede ser utilizado para realizar acciones cuando se active el evento.
    \item \textbf{Event Tick: }Evento que ocurre cada fotograma del videojuego y puede desencadenar acciones. Se utiliza para acciones que necesitan actualizaciones continuas, como la animación, el control del volante y los pedales o el seguimiento de otros objetos.
    \item \textbf{Event Hit: }Evento que se activa cuando un objeto colisiona con otro objeto. Puede utilizarse para realizar acciones específicas cuando ocurre una colisión.
    \item \textbf{Line Trace: }Técnica utilizada para determinar si hay algún objeto colisionando con una línea recta que se traza desde un origen hasta un destino. A esta técnica se le llama también \textit{raycasting}.
\end{itemize}

\newpage

\section{Algoritmos utilizados}

Voy a dividir en subsecciones los diversos algoritmos que componen la simulación:

\subsection{Algoritmo para el giro del volante del coche}
\label{sec:pid-sec}

En el control del volante de los vehículos, correspondiente a HU3 y realizada en el sprint 4, se ha utilizado un controlador PID (\textit{Proportional, Integral} y \textit{Derivative}). Este controlador se utiliza para regular el error de un sistema de manera suave, evitando producir muchas desviaciones mediante el ajuste de tres constantes, una para cada componente del controlador. Cabe destacar que la variable a la que el sistema debe llegar se llama SP (\textit{Set Point}) y el valor actual del sistema se denomina PV (\textit{Process Variable}). 

\bigskip

Para que el controlador funcione bien, es necesario modificar sus tres constantes: 
% Proporcional, Integral y Derivativa. 

\begin{itemize}
    \item \textbf{Proporcional: }Actuará de manera proporcional al error actual, multiplicada por la constante asociada. Si solo se utiliza este componente, el sistema se pasará del SP, haciendo que tenga que volver a corregir, produciendo así demasiadas oscilaciones para llegar al SP. 

    \item \textbf{Integral: }Se encarga de derivar el error con respecto al tiempo, con el objetivo de anular errores residuales e incluso del propio sensor. Por normal general, seguirá pasándose del SP, ya que de esto se encarga la componente derivativa.

    \item \textbf{Derivativa: }Se utiliza para estimar como evolucionará la curva con el tiempo, basándose en su pendiente. Esta componente es la que se encarga de minimizar las oscilaciones, al reducir el efecto del actuador si se acerca demasiado rápido al SP.
\end{itemize}

\bigskip

% \lstinputlisting[language={[Visual]C++}, caption={Implementación en C++ del controlador PID}, label={lst:pidcpp}]{snippets/PID.cpp}

\begin{listing}[H]
    \caption{Implementación en C++ del controlador PID}
    \inputminted[fontsize=\scriptsize, linenos, bgcolor=LightGray, frame=lines, framesep=3mm, baselinestretch=1.2]{C++}{snippets/PID.cpp}
    \label{lst:pidcpp}
\end{listing}

El rango de valores que pueden tener las variables dependen del sistema al que se aplique. No obstante, todos los valores son números reales positivos, incluyendo el 0, que deshabilita la componente.

\bigskip

Cabe destacar que, en mi caso, el SP es el punto más cercano del coche a la ruta generada, y el error es la distancia del coche a dicho punto.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{imagenes/converted/errorPID.jpg}
    \caption{Esquema donde se indica el cálculo de la distancia para el PID.}
    \label{fig:errorpid}
    \end{figure}

La calibración del PID se realiza modificando las constantes asociadas a cada componente. Existen diversos métodos como el de Ziegler-Nichols \cite{10.1115/1.4019264}, que consiste en modificar solo la parte proporcional, dejando las demás a 0, hasta que el sistema comience a oscilar de manera estable, en ese momento se debe calcular la frecuencia a la que oscila y utilizando también el valor de la constante proporcional, se pueden obtener las demás mediante un cálculo matemático.

\bigskip

Dado que este método no me dio los resultados deseados, decidí implementar un algoritmo genético para obtener las constantes del controlador PID (implementación del controlador en Listing \ref{lst:pidcpp}). Consiste en lanzar un conjunto de coches con valores positivos aleatorios para las constantes del PID, con el objetivo de que intenten llegar a la meta con el menor error posible (por error se sigue entendiendo como la distancia del punto más cercano a la ruta con el coche, véase Figura \ref{fig:errorpid}). Aquellos con menos error, tienen más posibilidades de ser seleccionados para generaciones futuras. Una vez obtenido el error, se calcula su inversa y se obtiene la probabilidad de ser elegido mediante el nuevo valor entre la suma de todos. Esto dará como resultado unas probabilidades que al ser sumadas darán 1 (100\%). 

\bigskip
% imagen de ejemplo de selección de ruleta
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{imagenes/converted/ruleta.jpg}
    \caption{Ilustración de la selección por ruleta}
    \label{fig:ruleta}
\end{figure}

La selección se realiza lanzando una ruleta\cite{gaperformance}, cuyos sectores son divididos en función de la probabilidad calculada anteriormente. La ruleta se debe lanzar tantas veces como padres se desea tener. Una vez que se han elegido los coches que van a ser padres, se emparejan y se mezclan sus constantes para obtener dos hijos de cada pareja. Después, una de las tres constantes del PID en algunos de los hijos puede ser mutada, con una probabilidad del 33\%, con un valor aleatorio de rango [-0.1,0.1] que se le añade al valor existente. Finalmente se sustituyen los coches no elegidos para la siguiente generación por los hijos con las constantes mezcladas y mutadas, manteniendo a los padres, y se vuelve a ejecutar de nuevo el algoritmo.

\bigskip

Utilizando este algoritmo, obtuve unos valores que funcionaban bien para el circuito. No obstante, tras ejecutarlo varias veces, me he dado cuenta de que la constante integral siempre tiende a 0. Para solucionarlo, he decidido obligarle a que tenga un valor mínimo de 0,1.


\subsection{Algoritmo de navegación}

En cuanto al algoritmo de navegación, correspondiente a HU2 e implementado en el sprint 5, he utilizado A*\cite{4082128}, que es lanzado utilizando diversas reglas, y una componente reactiva. 

\bigskip

A* es utilizado para obtener rutas en un grafo. Para ello, hace uso de una función heurística para estimar la distancia restante al nodo destino. A diferencia de otros algoritmos, como el de Dijkstra, A* es más rápido, gracias a la heurística, ya que puede descartar nodos que están más alejados del destino.

\bigskip

El algoritmo se encarga de visitar todos los nodos vecinos, calculando el coste de llegar desde el origen y el coste para llegar al destino mediante la heurística, en caso de encontrar una ruta mejor de un nodo ya existente en la lista de abiertos, se elimina el anterior y se introduce el nuevo. Este proceso se repite hasta que se llega al destino o, en mi caso, llega a un límite de iteraciones.

\bigskip

En la figura \ref{fig:rutaastar} se pueden observar unos cubos rojos, que representan la ruta generada por el algoritmo de navegación desde el checkpoint (véase Figura \ref{fig:checkpointunreal}) de la derecha hasta el de la izquierda.

% PONER EJEMPLOS DE RUTAS GENERADAS
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/converted/rutaAStar.jpg}
    \caption{Ruta generada por un vehículo hasta el siguiente checkpoint.}
    \label{fig:rutaastar}
\end{figure}


Realicé una primera implementación del algoritmo A* utilizando \textit{blueprints}. Sin embargo, había casos en los que el programa se quedaba congelado unos segundos hasta encontrar la ruta. La solución fue implementar en \textit{blueprints} una cola con prioridad utilizando un \textit{Binary Heap}, en vez de utilizar un algoritmo secuencial para la ordenación de los elementos. Esta versión provocó una gran mejora en el tiempo de ejecución, pero para carreras con más de dos coches, el tiempo de ejecución seguía siendo demasiado grande, haciendo que el programa se quedase parado unas décimas de segundo.

\bigskip

Finalmente opté por implementarlo en C++, utilizando como cola con prioridad el \textit{Binary Heap} que implementan los arrays (TArray) de Unreal. Esta versión ha conseguido que no se produzcan más paradas en la simulación, de manera que ahora pueden correr más de dos coches al mismo tiempo.

\subsubsection{Heurística}

% Debido a que un nodo puede moverse en 8 direcciones distintas, incluyendo las diagonales, es necesario utilizar una heurística acorde. Por tanto, he decidido utilizar la distancia Chebyshev\cite{enwiki:1149051498}, cuyos movimientos diagonales tienen el mismo coste que los demás. 

% \bigskip

% La configuración de los nodos prohíbe utilizar una heurística como la distancia Manhattan, ya que sobrestimaría la distancia al destino, haciendo que no sea correcto.

La heurística elegida ha sido la distancia Manhattan, ya que el rango de movimiento en la malla es solamente vertical y horizontal.

% foto diagrama de la distancia manhattan
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/Euclidean-and-Manhattan-distance-comparison-3235-Optimizations-The-first-optimization.png}
    \caption{Esquema del funcionamiento de la distancia Manhattan\cite{gameai}.}
    \label{fig:manhattan}
\end{figure}


\subsection{Generación de la malla de navegación}
Para que A* funcione, es necesario discretizar el espacio y crear una estructura de datos que permita incluir todos los posibles estados para que los pilotos puedan tomar decisiones.

\bigskip

% En cada subsección se hablará de cada componente que forma la malla de navegación:
A continuación se da una explicación de cada uno de los elementos que forman la malla de navegación:

\begin{itemize}
    \item \textbf{Nodo: }Para implementarlo, he creado un actor (véase sección \ref{sec:terminosunreal}) que representa un nodo. Además, posee las variables necesarias para saber si se encuentra un vehículo dentro de él, si es un delimitador de límites de pista, si es un checkpoint o si es una guía de ruta óptima. De esta forma se puede tener un control muy alto sobre los pesos de cada estado. Además, cada nodo almacena una referencia a sus nodos adyacentes, para que puedan ser utilizados por el algoritmo A*.
    
    \bigskip
    
    La actualización de un nodo de un estado a otro se realiza mediante el evento \textit{ActorBeginOverlap} y \textit{ActorEndOverlap} (véase sección \ref{sec:terminosunreal}). Así se puede actualizar el mapa en tiempo real.
    
    \bigskip
    
    Cabe destacar que los nodos con estado checkpoint y delimitador no pueden ser cambiados de estado; es decir, el delimitador de pista siempre estará ocupado, dándole un coste mayor. Mientras que el checkpoint siempre estará libre, dándole un coste menor. Los checkpoints nunca reciben colisión para optimizar la velocidad del algoritmo A*, ya que si se tienen en cuenta puede llegar a tardar demasiado en encontrar la ruta.
    
    \bigskip
    
    El estado ruta óptima sirve para darle una ayuda a los coches, ya que si no se utilizase escogería rutas más rígidas. Este estado no prohíbe a los coches la posibilidad de elegir otra ruta para adelantar o volver a pista, solo es una guía.
    
    \bigskip
    
    La construcción del delimitador y de la ruta óptima la he realizado utilizando actores distintos, de manera que se activen los eventos anteriormente mencionados para que se ajusten.

    \bigskip

    En la figura \ref{fig:nodo} se puede ver la representación de un nodo en el mapa. Asimismo, se puede observar como los nodos tienen cierta altura en el eje Z (mundo Z-Up), aun siendo utilizado para calcular una ruta en dos dimensiones. Esto se debe a que los vehículos deben solaparlos (con los eventos mencionados anteriormente) para poder actualizar cada nodo con el estado correcto.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\textwidth]{imagenes/converted/nodesCropped.jpg}
        \caption{Visualización de varios nodos en el mapa. Cada nodo es representado por ocho triángulos. Se han resaltado en color amarillo cuatro nodos.}
        \label{fig:nodo}
    \end{figure}

    \item \textbf{Malla (conjunto de nodos): }Para realizar la malla de navegación he utilizado un actor encargado de generar los nodos mencionados anteriormente en una malla de \gridSize. Como he dicho antes, estos valores pueden ser modificados, incluido el offset de donde comienza a generar nodos.
    
    \bigskip
    
    Este actor incluye los métodos necesarios para poder direccionar un nodo de la malla como una matriz (con filas y columnas), poder obtener su posición en coordenadas del mundo y poder convertir de coordenadas del mundo a coordenadas de matriz.

    % foto de la malla recreada en unreal
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{imagenes/converted/malla.jpg}
        \caption{Malla de navegación generada sobre el circuito. Los puntos rojos son muros, los verdes indicadores de ruta óptima y los azules el resto de la pista utilizable.}
        \label{fig:mallanav}
    \end{figure}
\end{itemize}


\subsection{Cálculo de la ruta por los vehículos}

Con todo lo anterior implementado el coche es capaz de obtener una ruta por el circuito. No obstante, sigue siendo demasiado costoso obtener una ruta demasiado larga, para luego tener que desecharla por un adelantamiento o un choque. Es por eso que he dividido el circuito en varios checkpoints de tamaño relativamente reducido, con el objetivo de que el cálculo de rutas sea más rápido.


% foto de los checkpoints
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imagenes/converted/checkpoints.jpg}
    \caption{Checkpoints utilizados a lo largo del circuito. Los checkpoints son las líneas de color blanco. Además, hay otra en la línea de meta.}
    \label{fig:checkpointunreal}
\end{figure}

Cuando la parte delantera del vehículo se solapa con un checkpoint, calcula la ruta utilizando A* hasta el siguiente. La llamada al algoritmo devuelve un vector de puntos en coordenadas del mundo. El vehículo se encarga de filtrar los puntos generados para que solo haya uno en cada checkpoint, ya que en otro caso puede generar problemas en el seguimiento de la ruta.

\bigskip

Con los puntos filtrados, el coche construye un spline y pinta los puntos en el suelo. Este spline será seguido gracias al controlador PID (Listing \ref{lst:pidcpp}) mencionado anteriormente. Cabe destacar que al ser la ruta discreta y el vehículo una componente física del mundo, el vehículo no siempre conseguirá seguirla siempre, pero le servirá como ``guía'' a la hora de tener que hacer giros y adelantamientos.

\newpage

\subsection{Lógica de adelantamiento de los vehículos}

Dado que los vehículos pueden tener ritmos distintos, los más veloces deben encontrar la forma de adelantar a los más lentos. Esta funcionalidad, correspondiente a HU4 e implementada en el sprint 6, permite realizar maniobras de adelantamiento para superar a los pilotos más lentos.

\bigskip

Las condiciones para que se lance el algoritmo son:

\begin{enumerate}
    \item El vehículo se encuentra cerca del de delante.
    \item El vehículo tiene más velocidad que el de delante.
    \item El vehículo a adelantar se encuentra en el mismo checkpoint o el siguiente.
\end{enumerate}

En caso de cumplirse todas las condiciones, se lanzará periódicamente el algoritmo de navegación, hasta que el piloto haya sido adelantado.

\bigskip

En la figura \ref{fig:overtake} se puede ver como se han dado las condiciones necesarias en el coche verde y ha recalculado la ruta para intentar adelantar al coche rojo.

% quizas poner foto, pero creo que va a ser complicado
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/converted/overtake.jpg}
    \caption{Cálculo de la ruta del coche verde para intentar adelantar al otro piloto.}
    \label{fig:overtake}
\end{figure}

\subsection{Recuperación después de un accidente}

Durante la carrera, existe la posibilidad de que los vehículos colisionen y queden atascados. Para abordar esta situación, se ha implementado un algoritmo de recuperación, correspondiente a HU5 y realizado en el sprint 6. 

\bigskip

El algoritmo comprueba si un coche lleva un intervalo de tiempo sin moverse. En caso afirmativo, echa marcha atrás durante unos segundos. Posteriormente, ejecuta el algoritmo de navegación para calcular una nueva ruta y lo recorre lentamente durante otro periodo de tiempo. Una vez trascurrido el tiempo, el piloto continua con la conducción normal en el circuito.


\subsection{Recuperación después del vuelco}

Puede darse el remoto caso de que un vehículo vuelque y no sea capaz de darse la vuelta. En este caso he decidido implementar una regla que comprueba si la rotación del coche es mayor de 90 grados en ambos sentidos, pone el coche de nuevo sobre sus cuatro ruedas.

% HERE: PONER FOTO DEL CODIGO PARA DAR LA VUELTA

\subsection{Frenada anticipativa para evitar colisión}
\label{sec:frenada}

Dado que mucha de las veces los vehículos calculan rutas casi idénticas, puede darse el caso de que el vehículo de atrás provoque un accidente con el de delante. Es por eso que es necesario implementar una forma para que los vehículos de detrás frenen. Esta funcionalidad corresponde a HU15 y se ha implementado en el sprint 9.

\bigskip

Para ello, he hecho uso de los \textit{Line Trace} (véase sección \ref{sec:terminosunreal}) para poder trazar un rayo hacia adelante y comprobar si hay un coche cerca. En la figura \ref{fig:esqlinetrace} aparece un boceto de como funciona:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.25\textwidth]{imagenes/converted/raycast.jpg}
    \caption{Esquema del trazado de rayos.}
    \label{fig:esqlinetrace}
\end{figure}

\bigskip

Además, para evitar colisiones entre vehículos, he calculado la distancia de los rayos en función de la velocidad, de forma que a mayor velocidad, mayor distancia del rayo. También he tenido en cuenta el nivel de agresividad y si el vehículo se encuentra al final de una recta, ya que existe el riesgo de colisionar con el vehículo de delante que frena antes y puede tener menor velocidad al no estar agresivo.

\bigskip

Los resultados obtenidos para niveles de agresividad altos son buenos, ya que en la mayoría de las ocasiones logra frenar a tiempo. Sin embargo, en algunas situaciones, se produce una colisión, lo cual simula el riesgo asumido por un piloto agresivo.

% HERE: PONER FOTO DEL CODIGO PARA FRENAR

\subsection{Rebufo de los vehículos}

Para dar algo más de realismo a la simulación, he implementado un sistema de rebufo básico. La implementación es similar a la de la sección \ref{sec:frenada}, utilizando \textit{Line Trace} para detectar si algún vehículo está delante, en caso afirmativo, se le aplica un impulso adicional al vehículo, de manera que tenga más aceleración de la normal.

\subsection{Control de acelerador y freno}

El control del acelerador y del freno en condiciones normales de carrera se implementa incluyendo en cada checkpoint (Figura \ref{fig:checkpointunreal}) la velocidad recomendada a la que debe ir el coche. El coche calcula la distancia a la que se encuentra del siguiente checkpoint y la distancia de frenado necesaria basándose en la velocidad y la desaceleración por el frenado (también se incluye la componente de agresividad).

\bigskip

Cabe destacar que esta velocidad es modificada por el estado del piloto, explicado en la sección \ref{sec:mod-estado-piloto}.

% HERE: AÑADIR FOTO DEL CODIGO QUE AUMENTA EL IMPULSO

\subsection{Algoritmo para las posiciones de los pilotos}

En lo que se refiere al cálculo de las posiciones de cada piloto, correspondientes a HU7 y HU8 e implementadas en el sprint 7, he utilizado una estructura de datos algo más compleja. Los vehículos almacenan la vuelta en la que están y el checkpoint; es decir, el sector del circuito en el que se encuentran. Con la información anterior, he creado un array asociativo que almacene como clave la vuelta y como valor otro array asociativo, que a su vez tiene como clave el checkpoint y como valor un array con todos los vehículos que se encuentran en ese estado. Para mostrarlo, solo hace falta iterar primero por aquellas claves mayores, ya que son los que más vueltas y más lejos del circuito están.

\begin{table}[H]
    \caption{Representación de la estructura de datos que almacena las posiciones de los pilotos durante la carrera.}
    \footnotesize
    \centering
    \begin{tblr}{
        cells = {c},
        row{1} = {Silver},
        cell{1}{2} = {c=2}{},
        cell{2}{1} = {r=4}{},
        cell{2}{2} = {Alto},
        cell{2}{3} = {Alto},
        cell{7}{1} = {r=2}{},
        cell{7}{2} = {Alto},
        cell{7}{3} = {Alto},
        vlines,
        hline{1-2,6-7,9} = {-}{},
        hline{3-5,8} = {2-3}{},
            }
        \textbf{Clave (vuelta actual)} & \textbf{Valor }                    &                \\
        0                              & \textbf{Clave (checkpoint actual)} & \textbf{Valor} \\
                                       & 0                                  & {[}c1]         \\
                                       & ...                                &                \\
                                       & i                                  & {[}c2, c3]     \\
        ...                            & ...                                & ...            \\
        i                              & \textbf{Clave (checkpoint actual)} & \textbf{Valor} \\
                                       & 3                                  & {[}c4]
    \end{tblr}
    \normalsize
    \label{fig:tablapos}
\end{table}

% Para saber cuando lanzar la actualización de la lista de posiciones, cada coche calcula si el que está por delante de él sigue así, en caso contrario lanza el evento de actualización.

Para saber cuando lanzar la actualización de la lista de posiciones, cada coche comprueba si ha conseguido adelantar al coche que estaba inmediatamente delante de él, en caso afirmativo lanza el evento de actualización.


\subsection{Contador de vueltas}

En cuanto a la actualización del contador de vueltas, correspondiente a HU9 y realizado en el sprint 8, he hecho que todos los coches cuando acaben una vuelta intenten actualizarlo, en caso de que la vuelta actual sea mayor o igual, no se actualiza. De esta forma, es más fácil llevar un control más preciso de las vueltas.

\subsection{Resultados de la simulación}

Cuando el último coche cruza la línea de meta, aparece una tabla con los resultados de la carrera. La implementación de esta funcionalidad la he hecho comenzando con un array vacío para almacenar los vehículos a medida que llegan a la meta. Al llegar el último vehículo, se genera la tabla con las posiciones correspondientes al array. En la figura \ref{fig:resultados-sim} se encuentra el boceto de la interfaz.


\subsection{Importación y exportación de la configuración}

En la importación y exportación de la configuración, correspondiente a HU10 y HU11 y realizadas en el sprint 8, he deseado que el usuario sea capaz de elegir la ubicación del archivo y la ruta de guardado, respectivamente. 

\bigskip

Unreal implementa los métodos ``OpenFileDialog'' y ``SaveFileDialog'' para abrir el cuadro de diálogo de Windows, pero solo están disponibles en las versiones de desarrollo, produciendo un error fatal cuando se utiliza en la aplicación compilada para ser distribuida, ya que el módulo con los métodos no se incluye. Para evitar que ocurra el error, he incluido todo el código de ambos métodos en una clase de C++ denominada ``FileDialogHandler'', con los métodos ``abrirArchivo'' y ``guardarArchivo'', de forma que se pueda utilizar en versiones de producción de la aplicación.

\bigskip

El formato del archivo generado es un JSON en el que se encuentran los atributos como: el número de vueltas, y cada uno de los coches con sus capacidades.

\bigskip

Para poder cargar y guardar los archivos, he utilizado el plugin ``JSON Blueprint Utilities'' de Epic Games, que viene por defecto en Unreal Engine 5, pero deshabilitado.

\subsection{Cambio entre distintas cámaras}

La funcionalidad de cambiar la cámara, correspondiente a HU17 y desarrollada en el sprint 9, permite visualizar la carrera entre tres tipos de perspectivas diferentes: cenital, frontal de un vehículo concreto y cámaras estáticas a lo largo del circuito, similar a como funciona en las carreras reales. El boceto de la interfaz con los botones aparece en la figura \ref{fig:boc-ui-race}.

\bigskip

El cambio se puede realizar pulsando sobre los botones con el símbolo de la cámara. Los botones que se encuentran a la derecha del nombre y apellidos del piloto corresponden a los frontales. Mientras que el botón de la derecha permite iterar entre las perspectivas cenitales y la de cámaras estáticas.

\bigskip

En las figuras \ref{fig:cenital}, \ref{fig:frontal} y \ref{fig:cam-estaticas} se muestran ejemplos de las diferentes perspectivas:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/camera/cam-top.jpg}
    \caption{Perspectiva cenital.}
    \label{fig:cenital}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/camera/cam-frontal.jpg}
    \caption{Perspectiva frontal del vehículo.}
    \label{fig:frontal}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/camera/cam-pers.jpg}
    \caption{Perspectiva de diversas cámaras.}
    \label{fig:cam-estaticas}
\end{figure}

Para realizar el seguimiento con cámaras estáticas, he reutilizado el actor (glosario en la sección \ref{sec:terminosunreal}) ``SplinePath'', utilizado en la creación de rutas del algoritmo A*. Mediante este actor, he creado un spline cuyos puntos son las posiciones que puede tener la cámara. Después, he creado el actor ``CameraFollower'', que tiene una referencia a todos los vehículos, de forma que elige cada cierto tiempo uno al azar y calcula el punto del spline más cercano al coche. Finalmente, mueve la cámara a dicho punto y la rota para que apunte en cada momento al coche.

\bigskip

En las figuras \ref{fig:bp-cam1} y \ref{fig:bp-cam2} se encuentra la implementación de la obtención del punto del spline y el movimiento de la cámara al objetivo, respectivamente:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/blueprints/CameraFollower.getCameraPosition.png}
    \caption{Implementación de la obtención del punto del spline.}
    \label{fig:bp-cam1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/blueprints/CameraFollower.moveCamera.png}
    \caption{Implementación del posicionamiento de la cámara.}
    \label{fig:bp-cam2}
\end{figure}

\subsubsection{Enmarcado del objetivo}

Debido al amplio rango de relaciones de aspecto con las que la aplicación puede trabajar, es posible que el objetivo sea enmarcado demasiado lejos o incluso se llegue a cortar. Para solucionarlo, es necesario ajustar los valores del FOV \textit{(Field Of View)} para que siempre se mantenga enmarcado. La modificación del FOV se realiza mediante una función lineal basada en los valores de FOV más coherentes para las relaciones de aspecto 1:1 y 21:9 y un ajuste manual de las constantes de la función. 

\bigskip

La función final es: $f(x) = 34.5865 \cdot x + 26.4135$, donde $x$ representa la relación de aspecto en formato numérico (diviendo ambos valores). Además, la he encapsulado en la clase ``CameraHandler'', para que los coches también puedan utilizar sus métodos.

\subsection{Cálculo de la zona de frenado}

Los coches necesitan saber en qué instante frenar para poder tomar las curvas sin salirse de pista. Con este fin, deben conocer la distancia al siguiente checkpoint donde deben comenzar a frenar.

\bigskip

He calculado la distancia de frenado utilizando la fórmula del MRUA (Movimiento Rectilíneo Uniformemente Acelerado) y despejando la distancia.

\bigskip

Partiendo de las fórmulas siguientes: 

$d = d_0 + v_0 \cdot t + \frac{1}{2} \cdot a \cdot t$

$v = v_0 + a \cdot t$

\bigskip

Al despejar la variable $t$ en la segunda fórmula y sustituirla en la primera, se procede a simplificar la expresión obteniendo: $ d = \frac{v^2-v_0^2}{2 \cdot a} $, donde $a$ es la deceleración, $v$ la velocidad a la que se quiere llegar y $v_0$ la velocidad actual.

\bigskip

Cabe destacar que la deceleración la he obtenido mediante el uso de otros vehículos con las mismas características que los utilizados en las carreras, pero con la capacidad de ser controlados con el teclado. Después, he calculado el valor G de la deceleración, el cual, al multiplicarlo por la gravedad, resulta en el valor final.
% de forma que multiplicado por la gravedad obtenga el valor final.

\newpage

\section{Modelado y texturizado de la escena}

Para la creación, preparación y modificación de los distintos modelos y texturas de la aplicación, he utilizado Blender\cite{blender} y GIMP\cite{gimp}. A continuación detallaré cada uno de los modelos y texturas, así como su proceso de generación.

\subsection{Trazado del circuito}

El trazado de la carretera lo he realizado creando primero un spline en Unreal con la forma deseada. A continuación, se debe incluir un modelo de carretera para que el spline pueda generarlo siguiendo la forma del trazado.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/converted/trazadoFinal.jpg}
    \caption{Trazado del circuito final.}
    \label{fig:trazado}
\end{figure}


En la vida real, los circuitos suelen tener secciones donde la carretera es recta y otras secciones donde se incluyen pianos, especialmente en las curvas. Por lo tanto, ha sido necesario crear tres modelos distintos de pista: uno sin piano, otro con piano a la izquierda y otro con el piano a la derecha. De esta manera, se logra una representación más fiel y realista de las diferentes secciones del circuito.

\bigskip

He utilizado Blender para generar los tres modelos de pista. Las secciones se construyeron a partir de un cubo achatado, y en las versiones con piano, se ha extruido uno de los lados y se ha aplicado un \textit{bevel} para suavizar las esquinas.

% fotos de las 3 versiones
\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/curva-recta.jpg}
        \caption{Sección recta de la curva.}
        \label{fig:curvarecta}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/curva.jpg}
        \caption{Sección con el piano a la izquierda.}
        \label{fig:curvaL}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/curva-inverted.jpg}
        \caption{Sección con el piano a la derecha.}
        \label{fig:curvaR}
    \end{subfigure}
    \caption{Modelos de pista utilizados.}
    \label{fig:curvasmodelos}
\end{figure}

Después, he utilizado la textura ``Asphalt 024 A''\cite{asphalt}, creada por Lennart Demes, y he modificado la componente difusa utilizando GIMP para poner una línea continua a ambos extremos, similar a los circuitos reales. Adicionalmente, he modificado la textura con las dos líneas para añadirle una sección con la línea de meta. En la figura \ref{fig:asfaltoTextura} se pueden observar ambas texturas.

\begin{figure}[H]
    \centering 
	\begin{subfigure}[t]{0.48\textwidth}
	    \centering
        \includegraphics[width=0.9\textwidth,cframe=black 1pt 0pt]{imagenes/converted/pista/Asphalt024A_2K_Color.jpg}
        \caption{Textura de asfalto modificada.}
        \label{fig:asfaltomod}
    \end{subfigure}
    \hfill 
    %\par\bigskip %si se desea dejar un margen entre la imagen de arriba y de abajo. SOLO SE PUEDE USAR HFILL O ESTE
    %\hspace{10px} %si se quiere poner una medida personalizada
	\begin{subfigure}[t]{0.48\textwidth}
	    \centering
	    \includegraphics[width=0.9\textwidth,cframe=black 1pt 0pt]{imagenes/converted/pista/Asphalt024A_2K_Color_FinishLineFinal.jpg}
        \caption{Textura de asfalto con la línea de meta.}
    \end{subfigure}    
    \caption{Texturas de asfalto utilizadas en la aplicación. Se han enmarcado para poder separar las imágenes del fondo de la página.}
    \label{fig:asfaltoTextura}
\end{figure}

Para texturizar el piano, he decidido crear la textura yo mismo. Utilizando GIMP, he creado una textura difusa con un tamaño de 2048x2048 píxeles y he pintado una mitad de color blanco y la otra de color rojo. 


\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{imagenes/converted/pista/kerb-dirty2.jpg}
    \caption{Textura utilizada para la componente difusa del piano.}
    \label{fig:pianodiff}
\end{figure}

El resultado en Unreal no era del todo convincente, ya que los bordes tenían demasiada iluminación. Para solucionarlo, he creado una textura para la componente de oclusión ambiental, de forma que los bordes sean algo más oscuros que la parte central. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth,cframe=black 0.5pt 0pt]{imagenes/converted/pista/kerb-dirty2-AO.jpg}
    \caption{Textura utilizada para la oclusión ambiental del piano. Enmarcado para diferenciar del fondo de la página.}
    \label{fig:pianoao}
\end{figure}

Estas texturas no encajaban del todo bien, haciendo que las líneas blancas no estuviesen alineadas con los bordes y que la textura del piano no se repitiese varias veces en la sección. Utilizando Blender, he realizado un mapeado UV de los modelos, con el objetivo de que la asignación de las texturas se realice correctamente.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{imagenes/converted/pista/uv-straight.jpg}
    \caption{Mapeado UV para la sección de asfalto.}
    \label{fig:uvasphalt}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{imagenes/converted/pista/uv-kerb.jpg}
    \caption{Mapeado UV para la sección de piano.}
    \label{fig:uvkerb}
\end{figure}

Ahora sí se sitúan bien las texturas en el modelo. En la figura \ref{fig:seccionespista} se encuentra el resultado final en Unreal.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/track-final.jpg}
        \caption{Sección de pista con el piano a la derecha.}
        \label{fig:curvafinal2}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/track-final-inverted.jpg}
        \caption{Sección de pista con el piano a la izquierda.}
        \label{fig:curvafinal3}
    \end{subfigure}
    \par\bigskip
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/track-straight-final.jpg}
        \caption{Sección de pista recta.}
        \label{fig:curvafinal1}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/converted/pista/track-finish-line-final.jpg}
        \caption{Sección de pista recta con la línea de meta.}
        \label{fig:curvafinishlinefinal}
    \end{subfigure}

    \caption{Secciones de pista finales en Unreal.}
    \label{fig:seccionespista}
\end{figure}

\newpage

\subsection{Preparación de los coches}

Debido a que modelar un vehículo requiere demasiado tiempo, he optado por utilizar el modelo ``Porsche 911 GT3''\cite{porsche} realizado por ``ChevroletSS'' y el modelo ``Mercedes F1 W14''\cite{f1} realizado por ``3dblenderlol''. Además, he eliminado toda clase de logotipos y marcas de los vehículos, para facilitar la exportación.

\bigskip

A continuación, es necesario preparar los modelos para que las ruedas se puedan mover en Unreal. Se debe realizar un \textit{rigging} de las ruedas; es decir, asignarle un conjunto de huesos, que actuarán como ejes para la rotación de las mismas. Esta tarea la he realizado cargando los modelos y utilizando el plugin de Blender ``UE4 Vehicle Rigging Addon for Blender''\cite{blenderplugin}, creado por ``Continue Break''. El plugin permite realizar el \textit{rigging} de manera automática con tan solo indicarle el chasis del coche y sus ruedas.

\begin{figure}[H]
    \centering
\begin{subfigure}[t]{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{imagenes/converted/rigging/911-rigging.jpg}
    \caption{\textit{Rigging} realizado en el Porsche 911.}
    \label{fig:rigging911}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.48\textwidth}
    \centering
    % \includegraphics[width=\textwidth]{imagenes/trazado.jpg}
    \includegraphics[width=\textwidth]{imagenes/converted/rigging/f1-rigging.jpg}
    \caption{\textit{Rigging} realizado en el coche de Fórmula 1.}
    \label{fig:riggingf1}
\end{subfigure}
\caption{\textit{Rigging} de los vehículos.}
\end{figure}

Así, ya se tendría realizado el \textit{rigging} de los vehículos. Ahora es necesario importarlos, crear sus animaciones y \textit{bounding boxes} para que funcione correctamente.

\newpage

\subsection{Barreras}

Es necesario establecer los límites del circuito mediante barreras similares a las utilizadas en los circuitos reales. Para ello, he decidido utilizar el modelo de valla ``3D Metal Fence''\cite{fence}, creado por ``Adrian Kulawik'', junto a un modelo de barrera creado por mí en Blender.

\bigskip

Debido a que quería simular que mi barrera está algo arrugada, como pasa en la vida real, he utilizado \textit{Sculpt Mode} para esculpir las diversas imperfecciones en un modelo de alta resolución. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{imagenes/converted/barrier/barrierHP.jpg}
    \caption{Barrera de alta resolución con imperfecciones.}
    \label{fig:barreraHP}
\end{figure}

Como puede consumir demasiados recursos, he convertido las deformaciones geométricas en una textura normal utilizando Blender, de manera que se pueda poner sobre una versión simple de la barrera.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{imagenes/converted/barrier/barrierNormal.jpg}
    \caption{Textura normal generada para la versión con pocos polígonos.}
    \label{fig:barreraLP}
\end{figure}


Y el modelo final es mi barrera, junto a la valla anteriormente mencionada encima.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{imagenes/converted/barrier/barrierfence.jpg}
    \caption{Resultado final de la barrera en Unreal.}
    \label{fig:barreraFinal}
\end{figure}

Para que la barrera rodee todo el circuito, se sigue un procedimiento similar al del trazado. Se utiliza un spline que marca el recorrido y, luego, se asigna una barrera a cada sección del spline.

\newpage

\subsection{Vegetación}

La vegetación del circuito está compuesta por césped en las curvas y por árboles en el exterior y zonas intermedias del circuito. El modelo de césped utilizado ha sido ``temperate Vegetation: optimized Grass Library''\cite{grass}, creado por ``Project Nature'', y el de los árboles es ``Megascans Trees: European Black Alder (early access)''\cite{trees}, creado por ``Quixel Megascans''.

\bigskip

El resultado final es el siguiente:

% fotos de cerca de arboles y cesped
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{imagenes/converted/cesped.jpg}
    \caption{Modelo de césped.}
    \label{fig:cesped}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{imagenes/converted/arboles.jpg}
    \caption{Modelo de árboles.}
    \label{fig:arboles}
\end{figure}

\subsection{Modelos y texturas adicionales}

% rescribir
He utilizado la textura de césped ``Ground 037''\cite{grasstexture}, creada por ``Lennart Demes'', para las zonas en las que se puso el modelo tridimensional de césped (modelo 3D en figura \ref{fig:cesped}), con el objetivo de dar más realismo en distancias más lejanas, donde el modelo tridimensional no se aprecia. 

\bigskip

Para evitar el efecto \textit{tiling}, he interpolado el color de la textura en dos tonos ligeramente diferentes mediante un patrón de variación. Además, he utilizado otro patrón de variación para incluir zonas oscuras en el césped. En la figura \ref{fig:grasstexture} se puede ver la textura utilizada y en la figura \ref{fig:grassfinal} el resultado final.

\begin{figure}[H]
    \centering
    % \includegraphics[width=\textwidth]{imagenes/trazado.jpg}
    \includegraphics[width=0.4\textwidth]{imagenes/converted/Ground037_1K_Color.jpg}
    \caption{Componente difusa de la textura de césped utilizada.}
    \label{fig:grasstexture}
\end{figure}

\begin{figure}[H]
    \centering
    % \includegraphics[width=\textwidth]{imagenes/trazado.jpg}
    \includegraphics[width=0.4\textwidth]{imagenes/converted/cespedTextFinal}
    \caption{Resultado final del césped en Unreal.}
    \label{fig:grassfinal}
\end{figure}

Para la zona de los alrededores del circuito, he utilizado la textura ``Coast Sand Rocks 02''\cite{coastsand}, creada por ``Rob Tuytel'', aplicándole el mismo tratamiento que al césped. Los resultados de utilizar solo esta textura no eran del todo convincentes, por lo que he decidido mezclarla con la textura ``Ground 066''\cite{ground066}, creada por ``Lennart Demes''. De esta forma he obtenido un buen resultado, sin apreciarse \textit{tiling}. En la figura \ref{fig:exterior} se pueden ver las texturas utilizadas y en la figura \ref{fig:sueloFinal} el resultado final:.

% Además, se ha hecho uso de la textura ``Coast Sand Rocks 02''\cite{coastsand}, creada por ``Rob Tuytel'', para el suelo del exterior del circuito, donde se encuentran los árboles (modelo 3D en figura \ref{fig:arboles}).

\begin{figure}[H]
    \centering 
	\begin{subfigure}[t]{0.48\textwidth}
	    \centering
        \includegraphics[width=\textwidth]{imagenes/converted/coast_sand_rocks_02_diff_4k.jpg}
        \caption{Componente difusa de la textura tierra y hierba del suelo.}
        \label{fig:coastsand}
    \end{subfigure}
    \hfill 
    %\par\bigskip %si se desea dejar un margen entre la imagen de arriba y de abajo. SOLO SE PUEDE USAR HFILL O ESTE
    %\hspace{10px} %si se quiere poner una medida personalizada
	\begin{subfigure}[t]{0.48\textwidth}
	    \centering
        \includegraphics[width=\textwidth]{imagenes/converted/Ground066_2K_Color.jpg}
        \caption{Componente difusa de la textura de tierra del suelo.}
        \label{fig:ground066}
    \end{subfigure}    
    \caption{Texturas utilizadas para el suelo exterior.}
    \label{fig:exterior}
\end{figure}

\begin{figure}[H]
    \centering
    % \includegraphics[width=\textwidth]{imagenes/trazado.jpg}
    \includegraphics[width=0.5\textwidth]{imagenes/converted/sueloTextFinal}
    \caption{Representación final del suelo.}
    \label{fig:sueloFinal}
\end{figure}

Por último, se ha utilizado el modelo ``Grand stand 3d model''\cite{grandstand}, creado por ``VT Studios'', para incluir algunas gradas en los alrededores del circuito.

\begin{figure}[H]
    \centering
    % \includegraphics[width=\textwidth]{imagenes/trazado.jpg}
    \includegraphics[width=\textwidth]{imagenes/converted/grandstand.jpg}
    \caption{Modelo de las gradas utilizadas.}
    \label{fig:grandstand}
\end{figure}